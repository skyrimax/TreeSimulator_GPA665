#include "Physics.h"

Vector airResistance(const Vector& wind, double length, double dia, double angularVelocity, double orientation)
{
	// Speed of the wind relative to the branch's linear speed
	Vector windRelativeToObj(wind - angularVelocityToLinearVelocity(length / 2, angularVelocity, orientation));
	// oriantation of the wind, relative to the moving branch
	double orientationWind = windRelativeToObj.orientation();

	// Aerodynamic drag equation : (ρ * |v|^2 * A * Cd)/2 * v_unitaire
	return ((1.2*pow(windRelativeToObj.norm(), 2)*projectedArea(orientationWind, dia, length)*dragCoefficient(orientationWind)) / 2)*windRelativeToObj.unit();
}

Vector angularVelocityToLinearVelocity(double s, double angularVelocity, double orientation)
{
	// Convert the angular speed of a stick (s) long to a linear speed, depending on it's
	// current orientation
	return Vector(-s*angularVelocity*sin(orientation), s*angularVelocity*cos(orientation));
}

double dragCoefficient(double angle)
{
	// Smooth transition from 0.6 for a cylinder at right angle with air stream
	// and 0.82 for a long cylinder with its axis parallel to the air stream
	// (Not a scientifically demonstrated relation, simply my own way of transitioning)
	return 0.11*cos(2 * angle) + 0.71;
}

double projectedArea(double angle, double dia, double length)
{
	// Area of a projection of a cylinder on a plane
	// at (90°-angle) with the axis of the cylinder
	return (pow(dia, 2)*sin(angle)*M_PI) / 4 + length * dia*cos(angle);
}

double torqueFromFlexion(double angle, double youngModulus, double radius, double length)
{
	double effetiveAngle;

	// Limiting the angle used to calculate the torque generated by the flexion to prevent
	// the branch going faster than the speed of light, thus angering the universe and making
	// tree shit itself, 'cause yes, it happened (5am comment, sorry)
	if (angle < -3) {
		effetiveAngle = -3;
	}
	else if (angle > 3) {
		effetiveAngle = 3;
	}
	else {
		effetiveAngle = angle;
	}

	// This formula is an approximation of the force generated by the flexion of the branch, derived
	// from the formulas of tractionh. Assumes only linear deformation and should not be used for
	// situations where lifes or a lot of money are on the line.
	// If you really want to know how I got that formula, contact me
	return (-32 * youngModulus*pow(radius, 4)*tan(effetiveAngle / 2)) / (9 * length * M_PI);
}

double massOfCylinder(double density, double radius, double length)
{
	// Density * volume
	return density * length*M_PI*pow(radius, 2);
}

double inertiaOfCylinder(double density, double radius, double length)
{
	// mass*(3r^2+h^2)/12
	return massOfCylinder(density, radius, length)*(3 * pow(radius, 2) + pow(length, 2)) / 12;
}
